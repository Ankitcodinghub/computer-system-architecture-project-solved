# computer-system-architecture-project-solved
**TO GET THIS SOLUTION VISIT:** [Computer System Architecture Project Solved](https://www.ankitcodinghub.com/product/computer-system-architecture-project-solved/)


---

üì© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
üì± **WhatsApp:** +1 419 877 7882  
üìÑ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;100348&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;1&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (1 vote)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;Computer System Architecture Project Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (1 vote)    </div>
    </div>
<div class="page" title="Page 1">
<div class="layoutArea">
<div class="column">
‚ÄúProcessor design is the design engineering task of creating a processor, a key component of computer hardware. The design process involves choosing an instruction set and a certain execution paradigm, and results in a microarchitecture. The mode of operation of any processor is the execution of lists of instructions. Instructions typically include those to compute or manipulate data values using registers, change or retrieve values in read/write memory, perform relational tests between data values and to control program flow.‚Äù

In this project, you will simulate a fictional processor design and architecture using Java. You are asked to choose one of four processor packages described in the upcoming sections.

Package Selection Form: https://forms.gle/7uwWNwsC9akPsdWt5

Project Selection Deadline: Wednesday 02/06/2021 at 11:59 pm

Note: The processor package choice is based on a first come, first served basis (each package has a maximum capacity of 25 teams).

Project Instructions

Please read the following instructions carefully:

<ol>
<li>a) &nbsp;Any case of plagiarism will result in a zero.</li>
<li>b) &nbsp;Any case of cheating will result in a zero.</li>
<li>c) &nbsp;A cheating detection tool will be used to compare the submitted projects against all online and offline implementations similar to the project idea.‚Ä¢ The projects that have more than 50% similarity percentage will receive a zero.</li>
<li>d) &nbsp;It is your responsibility to ensure that you have:‚Ä¢ Submitted before the deadline.

‚Ä¢ Submitted the correct file(s).

‚Ä¢ Submitted the correct file(s) names.</li>
<li>e) &nbsp;The project deadline is on Saturday 26/06/2021 at 11:59 pm.</li>
</ol>
</div>
</div>
<div class="layoutArea">
<div class="column">
1

</div>
</div>
</div>
<div class="page" title="Page 2">
<div class="layoutArea">
<div class="column">
1 Package 1: Fillet-O-Neumann with logical shifts on the side 1.1 Memory Architecture

a) Architecture: Von Neumann

‚Ä¢ Von Neumann Architecture is a digital computer architecture whose design is based on the concept of stored program computers where program data and instruction data are stored in the same memory.

</div>
</div>
<div class="layoutArea">
<div class="column">
b) Memory Size: 2048 * 32

</div>
</div>
<div class="layoutArea">
<div class="column">
Main Memory

32 Bits / Row

Data (1024 to 2047) Instructions (0 to 1023)

</div>
</div>
<div class="layoutArea">
<div class="column">
2048 Rows

</div>
</div>
<div class="layoutArea">
<div class="column">
‚Ä¢ The main memory addresses are from 0 to 211 ‚àí 1 (0 to 2047).

‚Ä¢ Each memory block (row) contains 1 word which is 32 bits (4 bytes). ‚Ä¢ The main memory is word addressable.

‚Ä¢ Addresses from 0 to 1023 contain the program instructions.

‚Ä¢ Addresses from 1024 to 2048 contain the data.

c) Registers: 33

‚Ä¢ Size: 32 bits

‚Ä¢ 31 General-Purpose Registers (GPRS)

‚Äì Names: R1 to R31 ‚Ä¢ 1 Zero Register

‚Äì Name: R0

‚Äì Hard-wired value ‚Äú0‚Äù (cannot be overwritten by any instruction). ‚Ä¢ 1 Program Counter

<ul>
<li>‚Äì &nbsp;Name: PC</li>
<li>‚Äì &nbsp;A program counter is a register in a computer processor that contains the address (loca-tion) of the instruction being executed at the current time.</li>
<li>‚Äì &nbsp;As each instruction gets fetched, the program counter is incremented to point to the nextinstruction to be executed.</li>
</ul>
1.2 Instruction Set Architecture

a) Instruction Size: 32 bits b) Instruction Types: 3

R-Format

OPCODE R1 R2 R3 SHAMT

4 5 5 5 13

I-Format

OPCODE R1 R2 IMMEDIATE

4 5 5 18 2

</div>
</div>
</div>
<div class="page" title="Page 3">
<div class="layoutArea">
<div class="column">
J-Format OPCODE ADDRESS 4 28

c) Instruction Count: 12

‚Ä¢ The opcodes are from 0 to 11 according to the instructions order in the following table:

</div>
</div>
<div class="layoutArea">
<div class="column">
Name

</div>
<div class="column">
Mnemonic Type

</div>
<div class="column">
Format

ADD R1 R2 R3 SUB R1 R2 R3 MULI R1 R2 IMM ADDI R1 R2 IMM

BNE R1 R2 IMM

ANDI R1 R2 IMM ORI R1 R2 IMM

J ADDRESS

SLL R1 R2 SHAMT SRL R1 R2 SHAMT LW R1 R2 IMM

SW R1 R2 IMM

</div>
<div class="column">
Operation

R1 = R2 + R3

R1 = R2 ‚Äì R3

R1 = R2 * IMM

R1 = R2 + IMM IF(R1 != R2) {

PC = PC+1+IMM } R1 = R2 &amp; IMM

R1 = R2 | IMM

PC = PC[31:28] || ADDRESS R1 = R2 &lt;&lt; SHAMT

R1 = R2 &gt;&gt;&gt; SHAMT

R1 = MEM[R2 + IMM] MEM[R2 + IMM] = R1

</div>
</div>
<div class="layoutArea">
<div class="column">
Add ADD Subtract SUB Multiply Immediate MULI Add Immediate ADDI

Branch if Not Equal BNE

And Immediate ANDI Or Immediate ORI Jump J Shift Left Logical‚àó SLL Shift Right Logical‚àó SRL Load Word LW Store Word SW

</div>
<div class="column">
R R I I

I

I I J R R I I

</div>
</div>
<div class="layoutArea">
<div class="column">
‚àó SLL and SRL: R3 will be 0 in the instruction format.

‚Äú||‚Äù symbol indicates concatenation (0100 || 1100 = 01001100).

1.3 Datapath

</div>
</div>
<div class="layoutArea">
<div class="column">
a) Stages: 5

<ul>
<li>All instructions regardless of their type must pass through all 5 stages even if they do not needto access a particular stage.</li>
<li>Instruction Fetch (IF): Fetches the next instruction from the main memory using the address in the PC (Program Counter).</li>
<li>Instruction Decode (ID): Decodes the instruction and reads any operands required from the register file.</li>
<li>Execute (EX): Executes the instruction. In fact, all ALU operations are done in this stage.</li>
<li>Memory (MEM): Performs any memory access required by the current instruction. For loads, it would load an operand from the main memory, while for stores, it would store an operand into the main memory.</li>
<li>Write Back (WB): For instructions that have a result (a destination register), the Write Back writes this result back to the register file.b) Pipeline: 4 instructions (maximum) running in parallel
<ul>
<li>Instruction Fetch (IF) and Memory (MEM) can not be done in parallel since they accessthe same physical memory.</li>
<li>At a given clock cycle, you can either have the IF, ID, EX, WB stages active, or the ID,EX, MEM, WB stages active.</li>
<li>Number of clock cycles: 7 + ((n ‚àí 1) ‚àó 2), where n = number of instructions‚Äì Imagine a program with 7 instructions: ‚àó 7+(6‚àó2)=19clockcycles
‚Äì You are required to understand the pattern in the example and implement it. 3
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="page" title="Page 4">
<div class="layoutArea">
<div class="column">
Package 1 Pipeline

</div>
</div>
<div class="layoutArea">
<div class="column">
Cycle 1 Cycle 2 Cycle 3 Cycle 4 Cycle 5 Cycle 6 Cycle 7 Cycle 8 Cycle 9 Cycle 10 Cycle 11 Cycle 12 Cycle 13 Cycle 14 Cycle 15 Cycle 16 Cycle 17 Cycle 18 Cycle 19

</div>
<div class="column">
Instruction Decode (ID)

Instruction 1 Instruction 1 Instruction 2 Instruction 2 Instruction 3 Instruction 3 Instruction 4 Instruction 4 Instruction 5 Instruction 5 Instruction 6 Instruction 6 Instruction 7 Instruction 7

</div>
<div class="column">
Execute (EX)

Instruction 1 Instruction 1

</div>
<div class="column">
Memory (MEM)

Instruction Instruction Instruction Instruction Instruction Instruction Instruction

</div>
<div class="column">
Write Back (WB)

1 2 3 4 5 6 7

</div>
</div>
<div class="layoutArea">
<div class="column">
Instruction Fetch (IF) Instruction 1

Instruction 2 Instruction 3 Instruction 4 Instruction 5 Instruction 6 Instruction 7

The pattern is as follows:

</div>
</div>
<div class="layoutArea">
<div class="column">
Instruction Instruction Instruction Instruction Instruction Instruction Instruction Instruction Instruction Instruction Instruction Instruction

</div>
<div class="column">
<pre>2
2
3
3
4
4
5
5
6
6
7
7
</pre>
</div>
<div class="column">
Instruction 1 Instruction 2 Instruction 3 Instruction 4 Instruction 5 Instruction 6 Instruction 7

</div>
</div>
<div class="layoutArea">
<div class="column">
2

2.1

</div>
<div class="column">
Package 2: Double Big Harvard combo large circular shifts Memory Architecture

</div>
</div>
<div class="layoutArea">
<div class="column">
‚Ä¢

</div>
</div>
<div class="layoutArea">
<div class="column">
<ul>
<li>‚Äì &nbsp;You fetch an instruction</li>
<li>‚Äì &nbsp;An instruction stays in the Decode (ID) stage for 2 clock cycles.</li>
<li>‚Äì &nbsp;An instruction stays in the Execute (EX) stage for 2 clock cycles.</li>
<li>‚Äì &nbsp;An instruction stays in the Memory (MEM) stage for 1 clock cycle.</li>
<li>‚Äì &nbsp;An instruction stays in the Write Back (WB) stage for 1 clock cycle.</li>
<li>‚Äì &nbsp;You can not have the Instruction Fetch (IF) and Memory (MEM) stages working in par-allel. Only one of them is active at a given clock cycle.</li>
</ul>
</div>
</div>
<div class="layoutArea">
<div class="column">
every 2 clock

</div>
<div class="column">
cycles starting from

</div>
<div class="column">
clock cycle 1.

</div>
</div>
<div class="layoutArea">
<div class="column">
a) Architecture: Harvard

‚Ä¢ Harvard Architecture is the digital computer architecture whose design is based on the concept where there are separate storage and separate buses (signal path) for instruction and data. It was basically developed to overcome the bottleneck of Von Neumann Architecture.

b) Instruction Memory Size: 1024 * 16

Instruction Memory

</div>
</div>
<div class="layoutArea">
<div class="column">
16 Bits / Row Rows

‚Ä¢ The instruction memory addresses are from 0 to 210 ‚àí 1 (0 to 1023). ‚Ä¢ Each memory block (row) contains 1 word which is 16 bits (2 bytes).

</div>
</div>
<div class="layoutArea">
<div class="column">
1024

</div>
</div>
<div class="layoutArea">
<div class="column">
4

</div>
</div>
</div>
<div class="page" title="Page 5">
<div class="layoutArea">
<div class="column">
‚Ä¢ The instruction memory is word addressable.

‚Ä¢ The program instructions are stored in the instruction memory.

c) Data Memory Size: 2048 * 8

Data Memory

8 Bits / Row

2048 Rows

‚Ä¢ The data memory addresses are from 0 to 211 ‚àí 1 (0 to 2047).

‚Ä¢ Each memory block (row) contains 1 word which is 8 bits (1 byte). ‚Ä¢ The data memory is word/byte addressable (1 word = 1 byte).

‚Ä¢ The data is stored in the data memory.

d) Registers: 66

‚Ä¢ Size: 8 bits

‚Ä¢ 64 General-Purpose Registers (GPRS)

</div>
</div>
<div class="layoutArea">
<div class="column">
‚Äì Names: R0 to R63 ‚Ä¢ 1 Status Register

</div>
</div>
<div class="layoutArea">
<div class="column">
76543210

000CVNSZ

</div>
</div>
<div class="layoutArea">
<div class="column">
‚Äì Name: SREG

‚Äì A status register, flag register, or condition code register (CCR) is a collection of status

flag bits for a processor.

‚Äì The status register has 5 flags updated after the execution of specific instructions:

<ul>
<li>‚àó &nbsp;Carry Flag (C): Indicates when an arithmetic carry or borrow has been generated out of the most significant bit position.¬∑ C = 1 if result &gt; Byte.MAX_VALUE

¬∑ C = 0 if result &lt;= Byte.MAX_VALUE

¬∑ Full cases and scenarios explanation:</li>
<li>‚àó &nbsp;Two‚Äôs Complement Overflow Flag (V): Indicates when the result of a signed number operation is too large, causing the high-order bit to overflow into the sign bit.
<ul>
<li>¬∑ &nbsp;If 2 numbers are added, and they both have the same sign (both positive or both negative), then overflow occurs (V = 1) if and only if the result has the opposite sign. Overflow never occurs when adding operands with different signs.</li>
<li>¬∑ &nbsp;If 2 numbers are subtracted, and their signs are different, then overflow occurs (V = 1) if and only if the result has the same sign as the subtrahend.</li>
<li>¬∑ &nbsp;The difference between carry and overflow is explained in: https://piazza.com/ class/kmoutjsotl76h5?cid=79</li>
</ul>
</li>
<li>‚àó &nbsp;Negative Flag (N): Indicates a negative result in an arithmetic or logic operation. ¬∑ N = 1 if result is negative.

¬∑ N = 0 if result is positive or zero.</li>
<li>‚àó &nbsp;Sign Flag (S): Indicates the expected sign of the result (not the actual sign).

¬∑ S = N ‚äï V (XORing the negative and overflow flags will calculate the sign flag).</li>
<li>‚àó &nbsp;Zero Flag (Z): Indicates that the result of an arithmetic or logical operation was zero. ¬∑ Z=1ifresultis0.</li>
</ul>
</div>
</div>
<div class="layoutArea">
<div class="column">
5

</div>
</div>
</div>
<div class="page" title="Page 6">
<div class="layoutArea">
<div class="column">
¬∑ Z=0ifresultisnot0.

‚àó Since all registers are 8 bits, and we are only using 5 bits in the Status Register for

the flags, you are required to keep Bits7:5 cleared ‚Äú0‚Äù at all times in the register. ‚Ä¢ 1 Program Counter

<ul>
<li>‚Äì &nbsp;Name: PC</li>
<li>‚Äì &nbsp;Type: Special-purpose register with a size of 16 bits (not 8 bits).</li>
<li>‚Äì &nbsp;A program counter is a register in a computer processor that contains the address (loca-tion) of the instruction being executed at the current time.</li>
<li>‚Äì &nbsp;As each instruction gets fetched, the program counter is incremented to point to the nextinstruction to be executed.</li>
</ul>
2.2 Instruction Set Architecture

</div>
</div>
<div class="layoutArea">
<div class="column">
a) Instruction Size: 16 bits b) Instruction Types: 2

</div>
</div>
<div class="layoutArea">
<div class="column">
R-Format OPCODE R1 R2

466

I-Format

OPCODE R1 IMMEDIATE

466

</div>
</div>
<div class="layoutArea">
<div class="column">
c) Instruction Count: 12

‚Ä¢ The opcodes are from 0 to 11 according to the instructions order in the following table:

</div>
</div>
<div class="layoutArea">
<div class="column">
Name

</div>
<div class="column">
Mnemonic Type

</div>
<div class="column">
Format

ADD R1 R2 SUB R1 R2 MULI R1 R2 LDI R1 IMM

BEQZ R1 IMM

AND R1 R2 ORR1R2 JRR1R2

SLC R1 IMM SRC R1 IMM

LB R1 ADDRESS SB R1 ADDRESS

</div>
<div class="column">
Operation

R1 = R1 + R2

R1 = R1 ‚Äì R2

R1 = R1 * R2

R1 = IMM

IF(R1 == 0) {

PC = PC+1+IMM } R1 = R1 &amp; R2

R1 = R1 | R2

PC = R1 || R2

R1 = R1 &lt;&lt; IMM | R1 &gt;&gt;&gt; 8 ‚Äì IMM R1 = R1 &gt;&gt;&gt; IMM | R1 &lt;&lt; 8 ‚Äì IMM R1 = MEM[ADDRESS] MEM[ADDRESS] = R1

</div>
</div>
<div class="layoutArea">
<div class="column">
Add ADD Subtract SUB Multiply MUL Load Immediate LDI

Branch if Equal Zero BEQZ

And AND Or OR Jump Register JR Shift Left Circular SLC Shift Right Circular SRC Load Byte LB Store Byte SB

</div>
<div class="column">
R R R I

I

R R R I I I I

</div>
</div>
<div class="layoutArea">
<div class="column">
‚Äú||‚Äù symbol indicates concatenation (0100 || 1100 = 01001100).

</div>
</div>
<div class="layoutArea">
<div class="column">
d) The Status Register (SREG) flags are affected by the following instructions:

<ul>
<li>The Carry flag (C) is updated every ADD, SUB, and MUL instruction.</li>
<li>The Overflow flag (V) is updated every ADD and SUB instruction.</li>
<li>The Negative flag (N) is updated every ADD, SUB, MUL, AND, OR, SLC, and SRC instruc- tion.</li>
</ul>
</div>
</div>
<div class="layoutArea">
<div class="column">
6

</div>
</div>
</div>
<div class="page" title="Page 7">
<div class="layoutArea">
<div class="column">
‚Ä¢ The Sign flag (S) is updated every ADD and SUB instruction.

‚Ä¢ The Zero flag (Z) is updated every ADD, SUB, MUL, AND, OR, SLC, and SRC instruction. ‚Ä¢ A flag value can only be updated by the instructions related to it.

2.3 Datapath

</div>
</div>
<div class="layoutArea">
<div class="column">
a) Stages: 3

<ul>
<li>All instructions regardless of their type must pass through all 3 stages.</li>
<li>Instruction Fetch (IF): Fetches the next instruction from the main memory using the address in the PC (Program Counter).</li>
<li>Instruction Decode (ID): Decodes the instruction and reads any operands required from the register file.</li>
<li>Execute (EX): Executes the instruction. In fact, all ALU operations are done in this stage. Moreover, it performs any memory access required by the current instruction. For loads, it would load an operand from the main memory, while for stores, it would store an operand into the main memory. Finally, for instructions that have a result (a destination register), it writes this result back to the register file.b) Pipeline: 3 instructions (maximum) running in parallel</li>
</ul>
</div>
</div>
<div class="layoutArea">
<div class="column">
‚Ä¢ Number of clock cycles: 3 + ((n ‚àí 1) ‚àó 1), where n = number of instructions ‚Äì Imagine a program with 7 instructions:

‚àó 3+(6‚àó1)=9clockcycles

‚Äì You are required to understand the pattern in the example and implement it.

</div>
</div>
<div class="layoutArea">
<div class="column">
Package 2 Pipeline

</div>
</div>
<div class="layoutArea">
<div class="column">
Cycle 1 Cycle 2 Cycle 3 Cycle 4 Cycle 5 Cycle 6 Cycle 7 Cycle 8 Cycle 9

</div>
<div class="column">
Instruction Fetch (IF) Instruction 1 Instruction 2 Instruction 3 Instruction 4 Instruction 5 Instruction 6 Instruction 7

</div>
<div class="column">
Instruction Decode (ID)

Instruction 1 Instruction 2 Instruction 3 Instruction 4 Instruction 5 Instruction 6 Instruction 7

</div>
<div class="column">
Execute (EX)

Instruction 1 Instruction 2 Instruction 3 Instruction 4 Instruction 5 Instruction 6 Instruction 7

</div>
</div>
<div class="layoutArea">
<div class="column">
3

3.1

</div>
<div class="column">
Package 3: Spicy Von Neumann Fillet with extra moves Memory Architecture

</div>
</div>
<div class="layoutArea">
<div class="column">
a) Architecture: Von Neumann

‚Ä¢ Von Neumann Architecture is a digital computer architecture whose design is based on the concept of stored program computers where program data and instruction data are stored in the same memory.

b) Memory Size: 2048 * 32

</div>
</div>
<div class="layoutArea">
<div class="column">
7

</div>
</div>
</div>
<div class="page" title="Page 8">
<div class="layoutArea">
<div class="column">
Main Memory

32 Bits / Row

Data (1024 to 2047) Instructions (0 to 1023)

‚Ä¢ The main memory addresses are from 0 to 211 ‚àí 1 (0 to 2047).

‚Ä¢ Each memory block (row) contains 1 word which is 32 bits (4 bytes). ‚Ä¢ The main memory is word addressable.

‚Ä¢ Addresses from 0 to 1023 contain the program instructions.

‚Ä¢ Addresses from 1024 to 2048 contain the data.

c) Registers: 33

‚Ä¢ Size: 32 bits

‚Ä¢ 31 General-Purpose Registers (GPRS)

‚Äì Names: R1 to R31 ‚Ä¢ 1 Zero Register

‚Äì Name: R0

‚Äì Hard-wired value ‚Äú0‚Äù (cannot be overwritten by any instruction). ‚Ä¢ 1 Program Counter

<ul>
<li>‚Äì &nbsp;Name: PC</li>
<li>‚Äì &nbsp;A program counter is a register in a computer processor that contains the address (loca-tion) of the instruction being executed at the current time.</li>
<li>‚Äì &nbsp;As each instruction gets fetched, the program counter is incremented to point to the nextinstruction to be executed.</li>
</ul>
3.2 Instruction Set Architecture

a) Instruction Size: 32 bits b) Instruction Types: 3

R-Format

OPCODE R1 R2 R3 SHAMT

4 5 5 5 13

I-Format

OPCODE R1 R2 IMMEDIATE

4 5 5 18

J-Format OPCODE ADDRESS 4 28

c) Instruction Count: 12

‚Ä¢ The opcodes are from 0 to 11 according to the instructions order in the following table:

</div>
</div>
<div class="layoutArea">
<div class="column">
2048 Rows

</div>
</div>
<div class="layoutArea">
<div class="column">
8

</div>
</div>
</div>
<div class="page" title="Page 9">
<div class="layoutArea">
<div class="column">
Name Mnemonic Type

</div>
<div class="column">
Format

ADDR1R2R3 SUBR1R2R3 MULR1R2R3 MOVI R1 IMM

JEQ R1 R2 IMM

ANDR1R2R3 XORI R1 R2 IMM JMP ADDRESS LSL R1 R2 SHAMT LSR R1 R2 SHAMT MOVR R1 R2 IMM MOVM R1 R2 IMM

</div>
<div class="column">
Operation

R1 = R2 + R3

R1 = R2 ‚Äì R3

R1 = R2 * R3

R1 = IMM

IF(R1 == R2) {

PC = PC+1+IMM } R1 = R2 &amp; R3

R1 = R2 ‚äï IMM

PC = PC[31:28] || ADDRESS R1 = R2 &lt;&lt; SHAMT

R1 = R2 &gt;&gt;&gt; SHAMT

R1 = MEM[R2 + IMM] MEM[R2 + IMM] = R1

</div>
</div>
<div class="layoutArea">
<div class="column">
Add ADD Subtract SUB Multiply MUL Move Immediate‚àó MOVI

Jump if Equal JEQ

And AND Exclusive Or Immediate XORI Jump JMP Logical Shift Left‚àó‚àó LSL Logical Shift Right‚àó‚àó LSR Move to Register MOVR Move to Memory MOVM

</div>
<div class="column">
R R R I

I

R I J R R I I

</div>
</div>
<div class="layoutArea">
<div class="column">
‚àó MOVI: R2 will be 0 in the instruction format.

‚àó‚àó LSL and LSR: R3 will be 0 in the instruction format.

‚Äú||‚Äù symbol indicates concatenation (0100 || 1100 = 01001100).

3.3 Datapath

</div>
</div>
<div class="layoutArea">
<div class="column">
<ol>
<li>a) &nbsp;Stages: 5
<ul>
<li>All instructions regardless of their type must pass through all 5 stages even if they do not needto access a particular stage.</li>
<li>Instruction Fetch (IF): Fetches the next instruction from the main memory using the address in the PC (Program Counter).</li>
<li>Instruction Decode (ID): Decodes the instruction and reads any operands required from the register file.</li>
<li>Execute (EX): Executes the instruction. In fact, all ALU operations are done in this stage.</li>
<li>Memory (MEM): Performs any memory access required by the current instruction. For loads, it would load an operand from the main memory, while for stores, it would store an operand into the main memory.</li>
<li>Write Back (WB): For instructions that have a result (a destination register), the Write Back writes this result back to the register file.</li>
</ul>
</li>
<li>b) &nbsp;Pipeline: 4 instructions (maximum) running in parallel
<ul>
<li>Instruction Fetch (IF) and Memory (MEM) can not be done in parallel since they accessthe same physical memory.</li>
<li>At a given clock cycle, you can either have the IF, ID, EX, WB stages active, or the ID,EX, MEM, WB stages active.</li>
<li>Number of clock cycles: 7 + ((n ‚àí 1) ‚àó 2), where n = number of instructions‚Äì Imagine a program with 7 instructions: ‚àó 7+(6‚àó2)=19clockcycles
‚Äì You are required to understand the pattern in the example and implement it.
</li>
</ul>
</li>
</ol>
</div>
</div>
<div class="layoutArea">
<div class="column">
9

</div>
</div>
</div>
<div class="page" title="Page 10">
<div class="layoutArea">
<div class="column">
Package 3 Pipeline

</div>
</div>
<div class="layoutArea">
<div class="column">
Cycle 1 Cycle 2 Cycle 3 Cycle 4 Cycle 5 Cycle 6 Cycle 7 Cycle 8 Cycle 9 Cycle 10 Cycle 11 Cycle 12 Cycle 13 Cycle 14 Cycle 15 Cycle 16 Cycle 17 Cycle 18 Cycle 19

</div>
<div class="column">
Instruction Decode (ID)

Instruction 1 Instruction 1 Instruction 2 Instruction 2 Instruction 3 Instruction 3 Instruction 4 Instruction 4 Instruction 5 Instruction 5 Instruction 6 Instruction 6 Instruction 7 Instruction 7

</div>
<div class="column">
Execute (EX)

Instruction 1 Instruction 1

</div>
<div class="column">
Memory (MEM)

Instruction Instruction Instruction Instruction Instruction Instruction Instruction

</div>
<div class="column">
Write Back (WB)

1 2 3 4 5 6 7

</div>
</div>
<div class="layoutArea">
<div class="column">
Instruction Fetch (IF) Instruction 1

Instruction 2 Instruction 3 Instruction 4 Instruction 5 Instruction 6 Instruction 7

The pattern is as follows:

</div>
</div>
<div class="layoutArea">
<div class="column">
Instruction Instruction Instruction Instruction Instruction Instruction Instruction Instruction Instruction Instruction Instruction Instruction

</div>
<div class="column">
<pre>2
2
3
3
4
4
5
5
6
6
7
7
</pre>
</div>
<div class="column">
Instruction 1 Instruction 2 Instruction 3 Instruction 4 Instruction 5 Instruction 6 Instruction 7

</div>
</div>
<div class="layoutArea">
<div class="column">
4

4.1

</div>
<div class="column">
Package 4: Double McHarvard with cheese arithmetic shifts Memory Architecture

</div>
</div>
<div class="layoutArea">
<div class="column">
‚Ä¢

</div>
</div>
<div class="layoutArea">
<div class="column">
<ul>
<li>‚Äì &nbsp;You fetch an instruction</li>
<li>‚Äì &nbsp;An instruction stays in the Decode (ID) stage for 2 clock cycles.</li>
<li>‚Äì &nbsp;An instruction stays in the Execute (EX) stage for 2 clock cycles.</li>
<li>‚Äì &nbsp;An instruction stays in the Memory (MEM) stage for 1 clock cycle.</li>
<li>‚Äì &nbsp;An instruction stays in the Write Back (WB) stage for 1 clock cycle.</li>
<li>‚Äì &nbsp;You can not have the Instruction Fetch (IF) and Memory (MEM) stages working in par-allel. Only one of them is active at a given clock cycle.</li>
</ul>
</div>
</div>
<div class="layoutArea">
<div class="column">
every 2 clock

</div>
<div class="column">
cycles starting from

</div>
<div class="column">
clock cycle 1.

</div>
</div>
<div class="layoutArea">
<div class="column">
a) Architecture: Harvard

‚Ä¢ Harvard Architecture is the digital computer architecture whose design is based on the concept where there are separate storage and separate buses (signal path) for instruction and data. It was basically developed to overcome the bottleneck of Von Neumann Architecture.

b) Instruction Memory Size: 1024 * 16

Instruction Memory

</div>
</div>
<div class="layoutArea">
<div class="column">
16 Bits / Row Rows

‚Ä¢ The instruction memory addresses are from 0 to 210 ‚àí 1 (0 to 1023). ‚Ä¢ Each memory block (row) contains 1 word which is 16 bits (2 bytes).

</div>
</div>
<div class="layoutArea">
<div class="column">
1024

</div>
</div>
<div class="layoutArea">
<div class="column">
10

</div>
</div>
</div>
<div class="page" title="Page 11">
<div class="layoutArea">
<div class="column">
‚Ä¢ The instruction memory is word addressable.

‚Ä¢ The program instructions are stored in the instruction memory.

c) Data Memory Size: 2048 * 8

Data Memory

8 Bits / Row

2048 Rows

‚Ä¢ The data memory addresses are from 0 to 211 ‚àí 1 (0 to 2047).

‚Ä¢ Each memory block (row) contains 1 word which is 8 bits (1 byte). ‚Ä¢ The data memory is word/byte addressable (1 word = 1 byte).

‚Ä¢ The data is stored in the data memory.

d) Registers: 66

‚Ä¢ Size: 8 bits

‚Ä¢ 64 General-Purpose Registers (GPRS)

</div>
</div>
<div class="layoutArea">
<div class="column">
‚Äì Names: R0 to R63 ‚Ä¢ 1 Status Register

</div>
</div>
<div class="layoutArea">
<div class="column">
76543210

000CVNSZ

</div>
</div>
<div class="layoutArea">
<div class="column">
‚Äì Name: SREG

‚Äì A status register, flag register, or condition code register (CCR) is a collection of status

flag bits for a processor.

‚Äì The status register has 5 flags updated after the execution of specific instructions:

<ul>
<li>‚àó &nbsp;Carry Flag (C): Indicates when an arithmetic carry or borrow has been generated out of the most significant bit position.
<ul>
<li>¬∑ &nbsp;C = 1 if result &gt; Byte.MAX_VALUE</li>
<li>¬∑ &nbsp;C = 0 if result &lt;= Byte.MAX_VALUE</li>
<li>¬∑ &nbsp;Full cases and scenarios explanation: https://piazza.com/class/kmoutjsotl76h5?cid=295</li>
</ul>
</li>
<li>‚àó &nbsp;Two‚Äôs Complement Overflow Flag (V): Indicates when the result of a signed number operation is too large, causing the high-order bit to overflow into the sign bit.
<ul>
<li>¬∑ &nbsp;If 2 numbers are added, and they both have the same sign (both positive or both negative), then overflow occurs (V = 1) if and only if the result has the opposite sign. Overflow never occurs when adding operands with different signs.</li>
<li>¬∑ &nbsp;If 2 numbers are subtracted, and their signs are different, then overflow occurs (V = 1) if and only if the result has the same sign as the subtrahend.</li>
<li>¬∑ &nbsp;The difference between carry and overflow is explained in: https://piazza.com/ class/kmoutjsotl76h5?cid=79</li>
</ul>
</li>
<li>‚àó &nbsp;Negative Flag (N): Indicates a negative result in an arithmetic or logic operation. ¬∑ N = 1 if result is negative.

¬∑ N = 0 if result is positive or zero.</li>
<li>‚àó &nbsp;Sign Flag (S): Indicates the expected sign of the result (not the actual sign).

¬∑ S = N ‚äï V (XORing the negative and overflow flags will calculate the sign flag).</li>
<li>‚àó &nbsp;Zero Flag (Z): Indicates that the result of an arithmetic or logical operation was zero. 11</li>
</ul>
</div>
</div>
</div>
<div class="page" title="Page 12">
<div class="layoutArea">
<div class="column">
¬∑ Z=1ifresultis0.

¬∑ Z=0ifresultisnot0.

‚àó Since all registers are 8 bits, and we are only using 5 bits in the Status Register for

the flags, you are required to keep Bits7:5 cleared ‚Äú0‚Äù at all times in the register. ‚Ä¢ 1 Program Counter

<ul>
<li>‚Äì &nbsp;Name: PC</li>
<li>‚Äì &nbsp;Type: Special-purpose register with a size of 16 bits (not 8 bits).</li>
<li>‚Äì &nbsp;A program counter is a register in a computer processor that contains the address (loca-tion) of the instruction being executed at the current time.</li>
<li>‚Äì &nbsp;As each instruction gets fetched, the program counter is incremented to point to the nextinstruction to be executed.</li>
</ul>
4.2 Instruction Set Architecture

</div>
</div>
<div class="layoutArea">
<div class="column">
a) Instruction Size: 16 bits b) Instruction Types: 2

</div>
</div>
<div class="layoutArea">
<div class="column">
R-Format OPCODE R1 R2

466

I-Format

OPCODE R1 IMMEDIATE

466

</div>
</div>
<div class="layoutArea">
<div class="column">
c) Instruction Count: 12

‚Ä¢ The opcodes are from 0 to 11 according to the instructions order in the following table:

</div>
</div>
<div class="layoutArea">
<div class="column">
Name

</div>
<div class="column">
Mnemonic Type

</div>
<div class="column">
Format

ADD R1 R2 SUB R1 R2 MULI R1 R2 MOVI R1 IMM

BEQZ R1 IMM

ANDI R1 IMM EOR R1 R2 BRR1R2

SAL R1 IMM

SAR R1 IMM

LDR R1 ADDRESS STR R1 ADDRESS

</div>
<div class="column">
Operation

R1 = R1 + R2

R1 = R1 ‚Äì R2

R1 = R1 * R2

R1 = IMM

IF(R1 == 0) {

PC = PC+1+IMM } R1 = R1 &amp; IMM

R1 = R1 ‚äï R2

PC = R1 || R2

R1‚àó = R1[7-IMM:0]] || 0 R1‚àó‚àó = R1[7] || R1[7:IMM] R1 = MEM[ADDRESS] MEM[ADDRESS] = R1

</div>
</div>
<div class="layoutArea">
<div class="column">
Add ADD Subtract SUB Multiply MUL Move Immediate MOVI

Branch if Equal Zero BEQZ

And Immediate ANDI Exclusive Or EOR Branch Register BR Shift Arithmetic Left SAL Shift Arithmetic Right SAR Load to Register LDR Store from Register STR

</div>
<div class="column">
R R R I

I

I R R I I I I

</div>
</div>
<div class="layoutArea">
<div class="column">
‚Äú||‚Äù symbol indicates concatenation (0100 || 1100 = 01001100).

‚àó 0 is repeated IMM times before right concatenating it to R1[7-IMM:0]. ‚àó‚àó R1[7] is repeated IMM times before left concatenating it to R1[7:IMM].

d) The Status Register (SREG) flags are affected by the following instructions:

‚Ä¢ The Carry flag (C) is updated every ADD, SUB, and MUL instruction. ‚Ä¢ The Overflow flag (V) is updated every ADD and SUB instruction.

</div>
</div>
<div class="layoutArea">
<div class="column">
12

</div>
</div>
</div>
<div class="page" title="Page 13">
<div class="layoutArea">
<div class="column">
<ul>
<li>The Negative flag (N) is updated every ADD, SUB, MUL, ANDI, EOR, SAL, and SAR instruction.</li>
<li>The Sign flag (S) is updated every ADD and SUB instruction.</li>
<li>The Zero flag (Z) is updated every ADD, SUB, MUL, ANDI, EOR, SAL, and SAR instruction.</li>
<li>A flag value can only be updated by the instructions related to it.4.3 Datapath
a) Stages: 3
</li>
</ul>
<ul>
<li>All instructions regardless of their type must pass through all 3 stages.</li>
<li>Instruction Fetch (IF): Fetches the next instruction from the main memory using the address in the PC (Program Counter).</li>
<li>Instruction Decode (ID): Decodes the instruction and reads any operands required from the register file.</li>
<li>Execute (EX): Executes the instruction. In fact, all ALU operations are done in this stage. Moreover, it performs any memory access required by the current instruction. For loads, it would load an operand from the main memory, while for stores, it would store an operand into the main memory. Finally, for instructions that have a result (a destination register), it writes this result back to the register file.b) Pipeline: 3 instructions (maximum) running in parallel
‚Ä¢ Number of clock cycles: 3 + ((n ‚àí 1) ‚àó 1), where n = number of instructions ‚Äì Imagine a program with 7 instructions:

‚àó 3+(6‚àó1)=9clockcycles

‚Äì You are required to understand the pattern in the example and implement it.
</li>
</ul>
</div>
</div>
<div class="layoutArea">
<div class="column">
Package 4 Pipeline

</div>
</div>
<div class="layoutArea">
<div class="column">
Cycle 1 Cycle 2 Cycle 3 Cycle 4 Cycle 5 Cycle 6 Cycle 7 Cycle 8 Cycle 9

The following guidelines

Program Flow

</div>
<div class="column">
Instruction Fetch (IF) Instruction 1 Instruction 2 Instruction 3 Instruction 4 Instruction 5 Instruction 6 Instruction 7

</div>
<div class="column">
Instruction Decode (ID)

Instruction 1 Instruction 2 Instruction 3 Instruction 4 Instruction 5 Instruction 6 Instruction 7

</div>
<div class="column">
Execute (EX)

Instruction 1 Instruction 2 Instruction 3 Instruction 4 Instruction 5 Instruction 6 Instruction 7

</div>
</div>
<div class="layoutArea">
<div class="column">
Guidelines

</div>
</div>
<div class="layoutArea">
<div class="column">
must followed in all packages:

</div>
</div>
<div class="layoutArea">
<div class="column">
a) You must write your program in assembly language in a text file.

b) Your must read the instructions from the text file, and parse them according to their types/formats (opcode and other relevant fields).

</div>
</div>
<div class="layoutArea">
<div class="column">
13

</div>
</div>
</div>
<div class="page" title="Page 14">
<div class="layoutArea">
<div class="column">
c) You must store the parsed version of the instructions in the memory (instruction segment of main memory or instruction memory according to your package).

<ol start="4">
<li>d) &nbsp;You should start the execution of your pipelined implementation by fetching the first instruc- tion from the memory (instruction segment of main memory or instruction memory) at Clock Cycle 1.</li>
<li>e) &nbsp;You should continue the execution based on the example provided in the Datapath section of each package reflecting the different stages working in parallel.</li>
<li>f) &nbsp;The Clock Cycles can be simulated as a variable that is incremented after finishing the required stages at a given time.‚Ä¢ Example:
fetch (); decode (); execute (); // memory();
</li>
</ol>
// writeback ();

cycles++;

Printings

The following items must be printed in the console after each Clock Cycle:

<ol>
<li>a) &nbsp;The Clock Cycle number.</li>
<li>b) &nbsp;The Pipeline stages:‚Ä¢ Which instruction is being executed at each stage?

‚Ä¢ What are the input parameters/values for each stage?</li>
<li>c) &nbsp;The updates occurring to the registers in case a register value was changed.</li>
<li>d) &nbsp;The updates occurring in the memory (data segment of main memory or data memory according to your package) in case a value was stored or updated in the memory.</li>
<li>e) &nbsp;The content of all registers after the last clock cycle.</li>
<li>f) &nbsp;The full content of the memory (main memory or instruction and data memories according to yourpackage) after the last clock cycle.</li>
</ol>
Submission

You should submit a ZIP file to the course email containing the following items:

<ul>
<li>All ‚Äú.java‚Äù code files used in the project.</li>
<li>Any additional library used.</li>
<li>A text file containing the team number, team name, package number and name, and team members‚Äô names, IDs, and tutorials.The ZIP file should be named in the following format: Team_[TeamNumber]_[PackageName]
‚Äì PackageNumber = {1, 2, 3, or 4} based on the selected/assigned project.
</li>
</ul>
</div>
</div>
<div class="layoutArea">
<div class="column">
14

</div>
</div>
</div>
